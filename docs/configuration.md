# Proxy Configuration
Each deployment of an EasyAuth Proxy is specific to:
- A single AAD tenant 
- A single App Registration within that tenant, which means a single set of scopes, roles, etc.
- A single Signup/Signin policy (if using Azure AD B2C)
- A single set of EasyAuth configuration options

You may protect multiple backend applications with a single proxy if, practically speaking, you are ok with managing access to these applications as a single "logical" application.  A common example of this scenario is a composite API that is served by multiple backend microservices.

For most stand-alone applications, however, you will probably elect to deploy a single EasyAuth proxy for each application

Here's a list of possible configuration options for the EasyAuth Proxy, which you can set in the *values.yaml* file of the helm chart or by providing an external configuration file:
| Parent | Name  | Usage  |
| - | - | - |
| azureAd | instance | The Azure Ad instance that will be used to authenticate users.  The default value of 'https://login.microsoftonline.com/' won't need to be changed in most cases, but you will need to provide the appropriate value if you are using a sovereign or government Azure tenant or using a custom url for Azure AD B2C.|
| azureAd | domain | Optional.  If your users are internal organizational accounts from a single tenant domain, this can be helpful by providing a "hint" during login to help ensure that the user logs in with the appropriate user account|
| azureAd | tenantId | If you are using the setup script, this value will be determined at runtime and filled in for you.  Otherwise, this is the GUID tenant identifier for the Azure AD tenant you want to use.  See [How to find my tenant id](https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-to-find-tenant)|
| azureAd | clientId | If you are using the setup script, this value will be determined at runtime and filled in for you.  Otherwise, this is the GUID application identifier for the Azure AD app registration you want to use.  See [App Registrations](https://docs.microsoft.com/en-us/graph/auth-register-app-v2)|
| azureAd | callbackPath | The path that Open Id Connect messages will be returned from Azure AD.  In the majority of cases, you should never need to change this.  See [Advanced Scenarios](docs/scenarios.md)|
| azureAd | signedOutCallbackPath | Reserved for future use - Not currently used|
| azureAd | signUpSignInPolicyId | For B2C only.  This is the name of the policy that should be used.  Otherwise, leave blank.|
| azureAd | clientSecretKeyRefName, clientSecretKeyRefKey | Secret container and key for the client secret.  Do not change these or set them directly or store the secret in a yaml file.  Rather, provide your secret to helm via the command line via *--set secret.azureclientsecret=$CLIENT_SECRET*  |
| easyAuthForK8s | dataProtectionFileLocation | data protection key ring location.  |
| easyAuthForK8s | signinPath | The path that the proxy host will respond to sign-in requests.  The default should not need to be changed, except for in [Advanced Scenarios](docs/scenarios.md).  Note that when changing this value, you must also update the *nginx.ingress.kubernetes.io/auth-signin* annotation in your ingresses to match.  |
| easyAuthForK8s | authPath | The path that the proxy host will respond to auth requests.  The default should not need to be changed, except for in [Advanced Scenarios](docs/scenarios.md).  Note that when changing this value, you must also update the *nginx.ingress.kubernetes.io/auth-url* annotation in your ingresses to match.  |
| easyAuthForK8s | allowBearerToken | Default is "false".  If "true" this will allow bearer tokens to be used in addition to cookies.  Primarily for API callers. |
| easyAuthForK8s | defaultRedirectAfterSignin |  This is the final fallback url that the user will be routed to after succesfully logging in.  Depending on your nginx configuration, the primary redirect preference will be the path provided by the "rd" query parameter, followed by the url that the user was originally trying to access.  This option provides a tertiary and final fallback, with "/" being the default |
| easyAuthForK8s | compressCookieClaims | Option is "true" by default, set "false" to disable. Experimental feature that serializes, compresses, and encodes the payload of non-essential claims to keep the cookie size as small as possible.  This helps to avoid increasing the nginx header buffers beyond the default settings and reduces the size of the data sent from the client with each request. <br/><br/>**WARNING!**: *This feature may introduce a security vulnerability, although no specific vulnerability is known at this time.  CRIME, a well-known exploit, takes advantage of compressed streams to decrypt data, however it requires the attacker to be able to introduce arbitrary data into the stream and observe its compressed state.  For this feature we are only compressing a portion of the payload which an attacker should not be able to manipulate, so it should be safe in theory.  To mitigate any potential concerns, avoid sending sensitive data to the back-end service, or disable this feature.*  |
| easyAuthForK8s | responseHeaderPrefix | Prefix for all user information headers.  Default is *"x-injected-"*.  There is no reason to change this unless you have multiple EasyAuth proxies protecting the same backend and need to discern the source of the headers.  |
| easyAuthForK8s | claimEncodingMethod | Default is *UrlEncode*, which should work for most situations.  Valid values are: <ul><li>*UrlEncode*: Invalid characters are escaped according to IETF RFC 3986</li><li>*Base64*: The full string value is encoded from UTF-8 bytes to base64 text</li><li>*None*: Value is not encoded, and the original string value is sent. This may cause errors for downstream web servers, especially on older platforms</li><li>*NoneWithReject*: No encoding is applied, but any header value containing an unsafe character is rejected, and the value "encoding_error" is sent in its place</li></ul> |
| easyAuthForK8s | headerFormatOption | How headers should be packaged.  Default is *Separate*. Note that regardless of the option you choose, only headers defined in the *nginx.ingress.kubernetes.io/auth-response-headers* ingress annotation will be sent to the back end.<ul><li>*Separate*: A separate header for each claim.</li><li>*Combined*: A single header *x-injected-userinfo* with a JSON object containing all claims.  See [Headers](docs/headers.md#Sample UserInfo Header) for an example.  If you choose this option, a common pattern is to use the Base64 encoding method as well since most applications that work with JSON data can also easily decode Base64 at the same time. </li></ul>|
# Ingress Configuration